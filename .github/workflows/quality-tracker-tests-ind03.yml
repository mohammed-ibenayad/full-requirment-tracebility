name: Quality Tracker Test Execution - Agnostic

on:
  repository_dispatch:
    types: [quality-tracker-test-run]

jobs:
  run-tests:
    runs-on: ubuntu-latest
    env:
      REQUIREMENT_ID: ${{ github.event.client_payload.requirementId }}
      REQUIREMENT_NAME: ${{ github.event.client_payload.requirementName }}
      TEST_CASE_IDS: ${{ join(github.event.client_payload.testCases, ' ') }}
      CALLBACK_URL: ${{ github.event.client_payload.callbackUrl }}
      GITHUB_RUN_ID: ${{ github.run_id }}
      REQUEST_ID: ${{ github.event.client_payload.requestId }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install project-specific dependencies
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Display execution info
        run: |
          echo "üéØ Requirement: $REQUIREMENT_ID - $REQUIREMENT_NAME"
          echo "üìã Test Cases: $TEST_CASE_IDS"
          echo "üîó GitHub Run ID: $GITHUB_RUN_ID"
          echo "üìù Request ID: $REQUEST_ID"
          echo "üì° Callback URL: $CALLBACK_URL"
          echo "‚ú® Agnostic Workflow: Using test-runner.sh"

      - name: Initialize results
        run: |
          python3 -c "
          import json, os, time
          test_ids = os.environ.get('TEST_CASE_IDS', '').split()
          results = []
          for test_id in test_ids:
              if test_id.strip():
                  results.append({
                      'id': test_id.strip(),
                      'name': f'Test {test_id.strip()}',
                      'status': 'Not Started',
                      'duration': 0,
                      'logs': '',
                      'rawOutput': '',
                      'errorStack': ''
                  })
          payload = {
              'requirementId': os.environ.get('REQUIREMENT_ID', ''),
              'requestId': os.environ.get('REQUEST_ID', ''),
              'timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
              'results': results
          }
          with open('current_results.json', 'w') as f:
              json.dump(payload, f, indent=2)
          print(f'üìã Initialized {len(results)} test results')
          "

      - name: Run tests
        run: |
          echo "üöÄ Starting test execution..."
          
          # Check for test-runner.sh and make it executable
          if [ ! -f "test-runner.sh" ]; then
              echo "‚ùå ERROR: test-runner.sh not found in repository root."
              exit 1
          fi
          chmod +x test-runner.sh
          
          IFS=' ' read -ra TEST_ARRAY <<< "$TEST_CASE_IDS"
          TOTAL_TESTS=${#TEST_ARRAY[@]}
          echo "üìä Total tests: $TOTAL_TESTS"
          mkdir -p test-results
          
          # Webhook sender function
          send_webhook() {
              local test_id="$1"
              local status="$2"
              local duration="$3"
              local raw_output="$4"
              local error_stack="$5"
              
              echo "üì° Webhook: $test_id -> $status"
              
              if [ -n "$CALLBACK_URL" ]; then
                  python3 -c "import json, os, time; data = {'requestId': os.environ.get('REQUEST_ID', ''), 'timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'results': [{'id': '$test_id', 'name': 'Test $test_id', 'status': '$status', 'duration': $duration, 'logs': 'Test execution info', 'rawOutput': '''$raw_output''', 'errorStack': '''$error_stack'''}]}; with open('webhook_${test_id}_${status}.json', 'w') as f: json.dump(data, f, indent=2);"
                  curl -w "Webhook response: %{http_code}" -o "response_${test_id}_${status}.txt" -X POST -H "Content-Type: application/json" -H "User-Agent: GitHub-Actions-Quality-Tracker" -H "X-GitHub-Run-ID: $GITHUB_RUN_ID" -H "X-Request-ID: $REQUEST_ID" -d @"webhook_${test_id}_${status}.json" "$CALLBACK_URL" --max-time 30 -s
                  sleep 0.5
              fi
              
              python3 -c "import json, os, time; try: with open('current_results.json', 'r') as f: payload = json.load(f); except: payload = {'requirementId': os.environ.get('REQUIREMENT_ID', ''), 'requestId': os.environ.get('REQUEST_ID', ''), 'timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'results': []}; test_id, status, duration, raw_output, error_stack = '$test_id', '$status', $duration, '''$raw_output''', '''$error_stack'''; updated = False; for result in payload['results']: if result['id'] == test_id: result.update({'status': status, 'duration': duration, 'logs': f'Test {status.lower()}', 'rawOutput': raw_output, 'errorStack': error_stack}); updated = True; break; if not updated: payload['results'].append({'id': test_id, 'name': f'Test {test_id}', 'status': status, 'duration': duration, 'logs': f'Test {status.lower()}', 'rawOutput': raw_output, 'errorStack': error_stack}); payload['timestamp'] = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()); with open('current_results.json', 'w') as f: json.dump(payload, f, indent=2); print(f'üìù Updated: {test_id} -> {status}');"
          }
          
          # Process each test
          CURRENT_TEST=0
          for test_id in "${TEST_ARRAY[@]}"; do
              if [ -z "$test_id" ]; then continue; fi
              
              CURRENT_TEST=$((CURRENT_TEST + 1))
              echo ""
              echo "üß™ [$CURRENT_TEST/$TOTAL_TESTS] Test: $test_id"
              
              output_file="test-results/output-${test_id}.log"
              
              send_webhook "$test_id" "Not Started" "0" "" ""
              send_webhook "$test_id" "Running" "0" "" ""
              
              start_time=$(date +%s)
              echo "‚ñ∂Ô∏è ./test-runner.sh \"$test_id\""
              
              if ./test-runner.sh "$test_id" > "$output_file" 2>&1; then
                  test_status="Passed"
                  echo "‚úÖ PASSED: $test_id"
              else
                  exit_code=$?
                  test_status="Failed"
                  echo "‚ùå FAILED: $test_id (exit: $exit_code)"
              fi
              
              end_time=$(date +%s)
              duration=$((end_time - start_time))
              
              # Read raw output and escape it for shell
              raw_output=""
              if [ -f "$output_file" ]; then
                  raw_output=$(python3 -c "import json, os; try: with open('$output_file', 'r', encoding='utf-8', errors='replace') as f: content = f.read(); if len(content) > 50000: content = content[:50000] + '\\n\\n[OUTPUT TRUNCATED]'; print(content.replace('\\\\', '\\\\\\\\').replace(\"'\", \"'\\\"'\\\"'\")); except Exception as e: print(f'Error reading file: {e}');")
              fi

              # Extract error stack if markers are present in the output
              error_stack=""
              if [ "$test_status" = "Failed" ]; then
                  error_stack_raw=$(awk '/##ERROR_STACK_START##/,/##ERROR_STACK_END##/' "$output_file")
                  if [ -n "$error_stack_raw" ]; then
                      echo "üîé Found error stack markers. Extracting stack."
                      error_stack=$(python3 -c "content = '''$error_stack_raw'''; print(content.replace('\\\\', '\\\\\\\\').replace(\"'\", \"'\\\"'\\\"'\"));")
                  fi
              fi
              
              send_webhook "$test_id" "$test_status" "$duration" "$raw_output" "$error_stack"
              
              echo "üìä Completed: $test_id -> $test_status (${duration}s)"
              sleep 1
          done
          
          echo ""
          echo "üèÅ All tests completed!"
        continue-on-error: true

      - name: Generate and Upload Artifacts
        run: |
          echo "üìä Generating final results..."
          if [ -f "current_results.json" ]; then
            cp current_results.json "results-$GITHUB_RUN_ID.json"
            echo "‚úÖ Results artifact: results-$GITHUB_RUN_ID.json"
          else
            echo "‚ùå No results file found"
          fi
          rm -f webhook_*.json response_*.txt
        
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_id }}
          path: |
            results-${{ github.run_id }}.json
            current_results.json
            test-results/
          retention-days: 7
          
      - name: Summary
        run: |
          echo "## üéØ Agnostic Test Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Requirement:** $REQUIREMENT_ID - $REQUIREMENT_NAME" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f current_results.json ]; then
            echo "**Results:**" >> $GITHUB_STEP_SUMMARY
            python3 -c "
            import json
            try:
                with open('current_results.json') as f: data = json.load(f)
                results = data.get('results', [])
                status_counts = {}
                for r in results:
                    status = r.get('status', 'Unknown')
                    status_counts[status] = status_counts.get(status, 0) + 1
                for status, count in status_counts.items():
                    emoji = {'Passed': '‚úÖ', 'Failed': '‚ùå'}.get(status, '‚ùì')
                    print(f'- {emoji} **{status}:** {count}')
            except Exception as e: print(f'- ‚ùå Error generating summary: {e}')
            " >> $GITHUB_STEP_SUMMARY
          fi
